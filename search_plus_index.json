{"./":{"url":"./","title":"前言","keywords":"","body":"&#x1F913; Odoo 小书这本书适合什么样的人群为了更好的阅读这本书下载源码文件这本书包含了什么内容文本约定声明联系我们支持我们&#x1F913; Odoo 小书 这本书适合什么样的人群 如果你是一名 Python 开发人员并且有一定的 Web 开发经验，希望学习和入门 Odoo 框架来高效开发业务应用，这本书可以给予你一些参考及帮助。 为了更好的阅读这本书 由于本书的 Demo 都是在 Ubuntu / Mac OS 操作系统下开发，并且使用 PostgreSQL 数据库，为了充分学习 Odoo ，我们建议在学习过程中查找相关文章或补充读物。 如果你使用的是 Windows 操作系统，建议使用 Ubuntu 虚拟机作为开发环境。 下载源码文件 本书涉及的所有源码文件均在 Github 仓库 Odoo-Book-Demo 中可以找到。 这本书包含了什么内容 这本书包含十一章，主要包含以下部分： 第一章，Odoo 框架介绍 —— 简单介绍 Odoo 框架背景，以及简单演示使用 Odoo 开发的应用。 第二章，Odoo 开发环境搭建 —— 从 Python 3 安装到 Odoo 源码获取一步一步搭建 Odoo 开发环境。 第三章，创建第一个 Odoo 应用 —— 如何启动和配置 Odoo，并利用脚手架工具创建并安装我们的第一个应用程序。 第四章，模型 Model —— 构建应用程序数据，介绍框架的对象关系映射（ORM），以及 ORM API 和可用的不同类型的模型以及字段类型， 包括关系字段和计算字段。 第五章，菜单 Menu —— 介绍 Odoo 组成应用的菜单部分，并且利用 XML 配置我们的第一个菜单。 第六章，视图 View —— 创建应用程序的视图部分，如最基本的列表、表单和搜索视图，以及看板视图。 第七章，动作 Action —— 利用动作关联菜单，实现进入到应用视图部分的功能，并利用最常见的几种动作实现相关的功能。 第八章，计划任务 Cron —— 明白计划任务可以实现的功能，并利用计划任务实现定时消息通知。 第九章，权限控制 Access Control —— 了解 Odoo 的常用几种权限控制的粗细粒度，包括权限组、菜单权限、模型权限和数据集权限， 通过实际的应用场景将权限应用结合并且实现。 第十章，Web 控制器 Web Controller —— 作为一个 Web 框架，肯定包含请求 (Request) 和响应（Response）的处理， 利用 Odoo 的 Web 控制器实现简单的接口，并且结合 Jinja2 模版引擎渲染一个简单的非 Odoo 视图的 Web 页面。 第十一章，模版引擎 QWeb —— QWeb 是一个网页框架，在 Odoo 8 中被初次使用，XML 模板引擎是它的核心，这一章节我们将学习 QWeb 的基础语法，并替换 Jinja2 模版引擎渲染的 Web 页面。 第十二章，国际化 i18n —— 为了能让我们的应用支持多语言，Odoo 也提供了国际化的解决方案，这一章节我们将学习如何让自己的应用实现国际化。 文本约定 本书中使用了如下文本约定。 一段代码文本如下： 当我们希望你重点注意的某个特定部分，或第一次出现的单词，相关的行或条目将标注显示，代码中则为注释： 这里是重点部分。 这里是第一次出现的单词。 'data': [ 'security/ir.model.access.csv', 'views/menu.xml', // 这里是注释 'views/list_view.xml', // 这里是注释 ]” 菜单或对话框中出现的单词会加上直角引号如： 在 Web 客户端中，访问「应用程序」顶部菜单并选择「更新应用程序列表」菜单选项。 其他说明 ⚠️ 警告或重要说明起来像这样。 &#x1F4A1; 提示和技巧看起来像这样。 声明 Odoo 小书由 TNK Studio 成员共同编写，采用 CC BY-NC-ND 4.0 许可协议发布。 您可以在遵守以下条件的前提下，自由地以任何形式共享本书： 署名 — 您必须给出适当的署名，提供指向本许可协议的链接，同时标明是否（对原始作品）作了修改。您可以用任何合理的方式来署名，但是不得以任何方式暗示许可人为您或您的使用背书。 非商业性使用 — 您不得将本作品用于商业目的。 禁止演绎 — 如果您再混合、转换、或者基于该作品创作，您不可以分发修改后的作品。 联系我们 本书为 Github 开源项目，项目地址 TNK-Studio/Odoo-Book &#x1F4D6; 如果你对本书有任何意见或建议，请在 issues 中提交，欢迎批评和指正 &#x1F44F; 支持我们 如果这本小书对您有帮助，欢迎投喂咖啡 ☕️ 给我们，或者给我们点个 &#x1F31F;，激励我们输出更多优质内容，感谢支持 &#x1F389; "},"Chapter-1/Odoo-Introduction.html":{"url":"Chapter-1/Odoo-Introduction.html","title":"Odoo 框架介绍","keywords":"","body":"Odoo 框架介绍Odoo 框架介绍 这一章节会简单介绍 Odoo 的历史背景和演示 Odoo 开发的应用。 "},"Chapter-1/Background-Introduction.html":{"url":"Chapter-1/Background-Introduction.html","title":"Odoo 背景介绍","keywords":"","body":"Odoo 背景介绍Odoo 背景介绍 Odoo（原名 OpenERP，更早之前则为 TinyERP），是一套企业资源规划（ERP）及客户关系管理（CRM）系统。以 Python 语言开发，数据库采用开源的 PostgreSQL，系统以 GNU GPL 开源协议发布。 系统提供较灵活的模块架构，常用模块包括：采购管理、销售管理、库存管理、财务管理、货品管理、营销管理、客户关系管理、生产管理、人事管理及服务支持等等。用户可以直接从模块库中选择安装适用模块，或进行模块卸载、升级的管理操作。 2005 年，Odoo 的创始人 Fabien Pinckaers 开始了 TinyERP 的开发，若干年后更名为 OpenERP，这其中有一段故事，感兴趣的朋友可以移步 Odoo 官网查看创始人发表的一篇内容 The Odoo Story. 在这之后 OpenERP 又一次经历了品牌升级，更名为我们现在所熟知的 Odoo，在 Odoo 的官网同样有一篇由 Fabien Pinckaers 发布的相关内容：Odoo: The New OpenERP. Odoo 分为社区版和企业版，社区版开源免费并遵循 AGPLv3 协议，而企业版则是在社区版的基础之上增加了一些商业特性和服务。截至本篇发布为止，最新版本为 Odoo 12，于 2018 年 10 月 3 日正式发布。 "},"Chapter-1/Odoo-Demonstration.html":{"url":"Chapter-1/Odoo-Demonstration.html","title":"Odoo 开发的应用简单演示","keywords":"","body":"Odoo 开发的应用简单演示Odoo 开发的应用简单演示 在 Odoo 的源码中有非常多开源的基于 Odoo 框架开发的企业应用。我们可以安装后直接使用，也可以用于学习 Odoo 框架。 所有的应用模块都是即插即用的方式，下面演示几个模块： Project 项目管理应用模块 该非常类似大多数项目管理工具，拥有看板视图，拖拽的交互方式，这些都是可以在开发我们自己的应用模块中用到。 Sale 销售应用模块 该模块有产品管理，商品编辑等，拥有 Web 商城后台所必须的基本功能。 当然也有向消费者展示的商城页面。 这些模块不仅可以给我们开发新的模块提供参考，并且 Odoo 的继承机制让我们可以基于这些应用模块进行扩展，使其更能满足我们的业务需求。希望读者们阅读完本书，也能基于 Odoo 开发自己的应用模块。 "},"Chapter-2/Odoo-Development-Environment.html":{"url":"Chapter-2/Odoo-Development-Environment.html","title":"Odoo 环境搭建","keywords":"","body":"Odoo 环境搭建Odoo 环境搭建 这一章节主要讲 Odoo 开发环境搭建，需要在 Ubuntu / Mac 操作系统下安装几个主要的工具和数据库。 其中会提到在安装 Postgres 数据库中遇到的一些问题，和如何利用 Node.js 版本管理工具 n 和 Python 版本管理工具 pyenv 等一些相对技巧性的知识。 最后讲如何利用 pipenv 来管理 Python 库的依赖而不是直接使用 pip 或 pip 和 virtualenv。 "},"Chapter-2/Installing-Git.html":{"url":"Chapter-2/Installing-Git.html","title":"安装 Git","keywords":"","body":"安装 GitUbuntu 安装 GitMac 安装 Git安装 Git Git 是一个分布式版本控制软件。 由于 Odoo 的源码获取和一系列其他工具的源码获取都需要用到 Git，所以我们先安装 Git。 Ubuntu 安装 Git $ sudo apt-get update $ sudo apt-get install git Mac 安装 Git $ brew install git &#x1F4A1; Mac 安装 Git 使用的是 Homebrew —— macOS 缺失的软件包的管理器，安装方法详见Homebrew 官网。 "},"Chapter-2/Installing-PostgreSQL.html":{"url":"Chapter-2/Installing-PostgreSQL.html","title":"安装 PostgreSQL","keywords":"","body":"安装 PostgreSQLUbuntu 安装 PostgreSQLUbuntu 17.04 - 17.10Ubuntu 14.04 16.04Mac OS启动 PostgreSQL 服务创建 PostgreSQL 用户和数据库安装 PostgreSQL PostgreSQL 是自由的对象-关系型数据库服务器（数据库管理系统），在灵活的 BSD 许可证下发行。 它在其他开放源代码数据库系统（比如 MySQL 和 Firebird），和专有系统（比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server）之外，为用户又提供了一种选择。 Ubuntu 安装 PostgreSQL 本书使用的 PostgreSQL 版本为 9.6 Ubuntu 17.04 - 17.10 $ sudo apt-get install postgresql-9.6 -y Ubuntu 14.04 16.04 $ sudo apt-get update $ sudo apt-get install lsb-release software-properties-common -y $ sudo add-apt-repository \"deb http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -sc)-pgdg main\" $ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - $ sudo apt-get update $ sudo apt-get install postgresql-9.6 -y Mac OS Mac 用户可以在下载官方 APP 来启动 PostgreSQL，带有版本管理，下载地址。也可以通过 Homebrew 进行安装。 $ brew install postgresql@9.6 启动 PostgreSQL 服务 $ sudo service postgresql start 创建 PostgreSQL 用户和数据库 创建 odoo 用户 $ sudo -u postgres -i $ createuser -P --superuser odoo 创建 odoo 数据库 $ createdb odoo -U odoo -W ⚠️ 若出现以下错误： FATAL: Peer authentication failed for user \"odoo\" 则需要将 pg_hba.conf 的配置： # cat pg_hba.conf ... # \"local\" is for Unix domain socket connections only local all all peer # IPv4 local connections: host all all 127.0.0.1/32 ident # IPv6 local connections: host all all ::1/128 ident 修改为： # cat pg_hba.conf ... # \"local\" is for Unix domain socket connections only local all all md5 # IPv4 local connections: host all all 127.0.0.1/32 md5 # IPv6 local connections: host all all ::1/128 md5 Ubuntu 配置文件路径 /etc/postgresql/9.6/main/pg_hba.conf Mac 配置文件路径 /Users/{username}/Library/Application Support/Postgres/var-9.6/pg_hba.conf "},"Chapter-2/Installing-Node.js-and-LESS.html":{"url":"Chapter-2/Installing-Node.js-and-LESS.html","title":"安装 Node.js 和 LESS","keywords":"","body":"安装 Node.js 和 LESS使用 Node 版本管理器 n 来安装 Node.js安装 Less安装 Node.js 和 LESS Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。 由于 Odoo 的样式文件使用 Less 语法编写，需要转译成 CSS，所以我们需要安装 Less 和 Node.js。 在搜索引擎上有非常多的 Node.js 安装教程，这里推荐一种简单且带版本控制的安装方法。 使用 Node 版本管理器 n 来安装 Node.js 安装方法非常简单，只需要运行： $ curl -L http://git.io/n-install | bash 运行后将会在 home 目录生成一个名为 n 的文件夹，里面包含了 n 的文件和 使用 n 安装的不同版本的 Node.js。 安装完成后提示需要重新打开终端或重新载入命令行配置文件。 若使用 bash 命令行，则运行： $ source ~/.bashrc 若使用 zsh 则运行： $ source ~/.zshrc n 安装完成后默认会安装当前 lts 版本的 Node.js，若需要安装指定版本的 Node.js，只需要输入 n 和版本号，例如： $ n 10.15.0 安装完成后，输入 n 和利用上下光标进行切换： node/8.15.0 ο node/10.15.0 本书中使用的 Node.js 版本为 10.15.0。 安装 Less 安装好 Node.js 之后接着安装 Less： $ npm install -g less &#x1F4A1; 若 less 安装速度较慢，可以将 npm 源替换为淘宝的镜像源，参考网址。 "},"Chapter-2/Get-Odoo-Source.html":{"url":"Chapter-2/Get-Odoo-Source.html","title":"获取 Odoo 源码","keywords":"","body":"获取 Odoo 源码获取 Odoo 源码 Odoo 是一个开源项目，我们可以轻松的在 Github 上找到它的源码。 本书中使用的是 12.0 版本的 Odoo，所以在拉取代码时选择 12.0 的分支。 确保拉取的速度，使用--depth参数。 git clone https://github.com/odoo/odoo.git -b 12.0 --depth=1 ./odoo_dev 为了熟悉和学习源码，我们直接将源码克隆到 odoo_dev 目录下，并且后续的 Demo 开发和知识点讲解都是直接在该目录下进行的。 "},"Chapter-2/Installing-Python3.html":{"url":"Chapter-2/Installing-Python3.html","title":"安装 Python3","keywords":"","body":"安装 Python3使用 pyenv 安装 Python3安装 Python3 本书使用的 Python 版本为 3.6.5 如果已经安装了该版本的 Python 或已经熟悉使用 pyenv，可以跳过这一章节 使用 pyenv 安装 Python3 开始安装 Odoo 依赖之前，考虑到每个人的 Python 环境不一致，所以就讲解一下如何利用 pyenv 安装不同版本的 Python。 在命令行直接输入： $ sudo curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 执行完成后会提示需要将以下内容加入命令行配置文件： export PATH=\"/root/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" export LC_ALL=C.UTF-8 export LANG=C.UTF-8 使用 bash 命令行则加入到 ~/.bashrc 文件末尾，并执行 source ~/.bashrc。 使用 zsh 命令行则加入到 ~/.zshrc 文件末尾，并执行 source ~/.zshrc。 配置生效后，即可通过执行以下命令来安装 Python： $ pyenv install 3.6.5 Python 安装成功后，可以使用以下命令来切换全局的 Python 版本： $ pyenv global 3.6.5 ⚠️ 若使用 Ubuntu 请确保系统中有 Python 依赖，命令来自Common build problems $ sudo apt-get install -y gcc make build-essential libssl-dev zlib1g-dev libbz2-dev \\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\ xz-utils tk-dev libffi-dev liblzma-dev libldap2-dev libsasl2-dev &#x1F4A1; 若使用 pyenv install 3.6.5 安装速度过慢，可以先在搜狐的镜像下载源码包，放到 pyenv 的 cache 目录后在执行安装指定版本，例如： $ v=3.6.5;wget https://npm.taobao.org/mirrors/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v "},"Chapter-2/Use-Pipenv-Installing-Dependencies.html":{"url":"Chapter-2/Use-Pipenv-Installing-Dependencies.html","title":"使用 pipenv 安装依赖","keywords":"","body":"使用 pipenv 安装依赖初始化 Pipfile安装依赖 激活虚拟环境使用 pipenv 安装依赖 Pipenv 会自动帮你管理虚拟环境和相关依赖，并且提供了一系列命令和选项来帮助你实现各种依赖和环境管理相关的操作。 简而言之，它更方便、完善和安全。 本书强烈建议使用 pipenv 来管理环境依赖来养成良好的环境管理习惯，当然你也可以跳过这一章节直接使用 pip 以及 odoo_dev 中的 requirements.txt 来安装依赖，若熟悉 pipenv 可以跳过这一章节。 安装之前需要删除 requirements.txt 中的最后一行 pypiwin32 ; sys_platform == 'win32' 并保存。 初始化 Pipfile 首先输入以下命令生成 Pipfile： $ pipenv --python 3.6.5 Warning: Python 3.6.5 was not found on your system... Would you like us to install CPython 3.6.5 with pyenv? [Y/n]: 若出现以上提示则可以参考安装 Python3来安装对应的 Python 版本，当然你也可以直接输入 Y 使用 pyenv 来安装。 虚拟环境创建成功后会有类似的内容输出： Creating a virtualenv for this project… Pipfile: /root/odoo_dev/Pipfile Using /root/.pyenv/versions/3.6.5/bin/python3.6m (3.6.5) to create virtualenv… ⠦ Creating virtual environment...Using base prefix '/root/.pyenv/versions/3.6.5' New python executable in /root/.local/share/virtualenvs/odoo_dev-PjULxt24/bin/python3.6m Also creating executable in /root/.local/share/virtualenvs/odoo_dev-PjULxt24/bin/python Installing setuptools, pip, wheel... done. Running virtualenv with interpreter /root/.pyenv/versions/3.6.5/bin/python3.6m ✔ Successfully created virtual environment! Virtualenv location: /root/.local/share/virtualenvs/odoo_dev-PjULxt24 requirements.txt found, instead of Pipfile! Converting… ✔ Success! Warning: Your Pipfile now contains pinned versions, if your requirements.txt did. We recommend updating your Pipfile to specify the \"*\" version, instead. Pipenv 会自动在 ~/.local/share/virtualenvs 目录下新建一个虚拟环境 virtualenv 目录，目录名一般为odoo_dev-*，若在当前目录下存在 requirements.txt 文件时，会自动安装里面的库及依赖，并写入到 Pipfile 中。 可以使用 cat 查看一下 Pipfile 中的内容： [[source]] name = \"pypi\" url = \"https://pypi.org/simple\" verify_ssl = true [dev-packages] [packages] babel = \"==2.3.4\" chardet = \"==3.0.4\" decorator = \"==4.0.10\" docutils = \"==0.12\" ebaysdk = \"==2.1.5\" feedparser = \"==5.2.1\" gevent = \"==1.3.4\" greenlet = \"==0.4.13\" html2text = \"==2016.9.19\" libsass = \"==0.12.3\" lxml = \"==4.2.3\" mako = \"==1.0.4\" mock = \"==2.0.0\" num2words = \"==0.5.6\" ofxparse = \"==0.16\" passlib = \"==1.6.5\" pillow = \"==4.0.0\" psutil = \"==4.3.1\" psycopg2 = \"==2.7.3.1\" pydot = \"==1.2.3\" pyldap = \"==2.4.28\" pyparsing = \"==2.1.10\" pypdf2 = \"==1.26.0\" pyserial = \"==3.1.1\" python-dateutil = \"==2.5.3\" pytz = \"==2016.7\" pyusb = \"==1.0.0\" qrcode = \"==5.3\" reportlab = \"==3.3.0\" requests = \"==2.20.0\" suds-jurko = \"==0.6\" vatnumber = \"==1.2\" vobject = \"==0.9.3\" xlsxwriter = \"==0.9.3\" xlwt = \"==1.3.*\" xlrd = \"==1.0.0\" Jinja2 = \"==2.8.1\" MarkupSafe = \"==0.23\" Werkzeug = \"==0.11.15\" [requires] python_version = \"3.6\" 安装依赖 激活虚拟环境 安装 Pipfile 中的依赖我们只需要执行 $ pipenv install 最后再执行以下命令就可以激活我们的虚拟环境了 $ pipenv shell ⚠️ 若使用 Ubuntu 系统且依赖中的 pyldap 安装失败显示 fatal error: lber.h: No such file or directory，则需要先安装以下库： $ sudo apt-get install -y libldap2-dev libsasl2-dev &#x1F4A1; 若执行 pipenv install 速度过慢，可以将 Pipfile 中的 source url 修改为： url = \"http://mirrors.aliyun.com/pypi/simple\" "},"Chapter-2/Start-Odoo.html":{"url":"Chapter-2/Start-Odoo.html","title":"启动 Odoo","keywords":"","body":"启动 Odoo启动 Odoo 在我们拉取的源码的根目录下有一个 odoo-bin 的 Python 脚本文件，这个是 Odoo 的启动脚本。 运行该脚本之后会在8069默认端口启动 Odoo 服务，启动之前需要运行 pipenv shell 进入虚拟环境。 &#x1F4A1; 如果是用 Pycharm 启动首先需要在 Preferences > Project > Project Interpreter > Add > Existing Environment 中 将使用 pipenv 生成的 Python 添加进去，一般 pipenv 生成的虚拟环境目录在 ~/.local/share/virtualenvs/，如果是按照上一篇生成的虚拟环境， 则目录则为 ~/.local/share/virtualenvs/odoo_env-* (* 号为随机字符串)。 运行 Odoo 启动脚本： $ pipenv shell $ ./odoo-bin 2019-01-08 14:23:16,295 118 INFO ? odoo: Odoo version 12.0 2019-01-08 14:23:16,296 118 INFO ? odoo: addons paths: ['/root/.local/share/Odoo/addons/12.0', '/root/odoo_dev/odoo/addons', '/root/odoo_dev/addons'] 2019-01-08 14:23:16,296 118 INFO ? odoo: database: default@default:default 2019-01-08 14:23:16,380 118 INFO ? odoo.addons.base.models.ir_actions_report: You need Wkhtmltopdf to print a pdf version of the reports. 2019-01-08 14:23:16,477 118 INFO ? odoo.service.server: HTTP service (werkzeug) running on 074d4c08f8b7:8069 然后我们使用浏览器访问http://localhost:8069，这时候可能会出现： odoo.sql_db: Connection to the database failed ... psycopg2.OperationalError: FATAL: role \"xxx\" does not exist - - - 出现这个错误的原因是我们还没有在 Odoo 启动配置文件 里配置数据库账号和密码，但是 Odoo 的启动配置文件在哪里呢。 我们在命令行输入： $ ./odoo-bin --help ... Common options: -c CONFIG, --config=CONFIG specify alternate config file -s, --save save configuration to ~/.odoorc (or to ~/.openerp_serverrc if it exists) ... 可以看到使用 -s 或 --save 参数，Odoo 会在 home 目录下生成 .odoorc 配置文件，并且用 -c 参数可以指定启动的配置文件。 &#x1F4A1; 若不指定 Odoo 的运行配置文件，并且 home 目录下存在 .odoorc 配置文件，则 Odoo 默认会选择这个作为启动的配置文件。 于是我们可以先运行，然后在 Ctrl + C 停止 Odoo： $ ./odoo-bin -s ... 2019-01-08 14:37:57,127 152 INFO ? odoo.service.server: Hit CTRL-C again or send a second signal to force the shutdown. 然后编辑 ~/.odoorc 文件，将 db_user 和 db_password 分别修改为我们在安装 PostgreSQL时设置的用户 odoo 和这个用户的密码。 ... db_password = **** ... db_user = odoo ... 再次运行启动脚本启动 Odoo，这时已经可以成功访问 http://localhost:8069 了，并且进入的是一个数据库选择页面， 我们可以直接选择 odoo 数据库或者点击 「Manage Databases」跳转到数据库创建页面。 选择好数据库之后，就可以进入到 Odoo 的登陆界面了，默认的管理员账号密码均为 admin。 为了在进入 Odoo 时防止每次都要显示数据库选择界面，我们将配置文件的 db_name 参数设置为我们的数据库名称，例如：db_name=odoo，或者在启动参数增加 -d odoo。 &#x1F4A1; 为了方便的修改 Odoo 的配置文件，可以复制 ~/.odoorc 到项目根目录下如 ./odoorc.ini，执行时增加 -c ./odoorc.ini 参数指定配置文件。 ⚠️ 若出现以下错误 $ ERROR ? odoo.modules.loading: Database odoo not initialized, you can force it with `-i base` 则在启动参数添加 -i base 参数，他会初始化 odoo 的基础数据到 postgresql 中。 $ ./odoo-bin -c ./odoorc.ini -d odoo -i base "},"Chapter-3/Create-Your-First-addon.html":{"url":"Chapter-3/Create-Your-First-addon.html","title":"创建第一个 Odoo 应用","keywords":"","body":"创建第一个 Odoo 应用创建第一个 Odoo 应用 在这一章节中，我们将会学习如何自己开发一个 Odoo 应用。 本书将以一个追番剧应用作为例子来讲解 Odoo 开发的主要知识点。 这个追番剧应用的主要功能如下图所示： "},"Chapter-3/Odoo-Scaffold.html":{"url":"Chapter-3/Odoo-Scaffold.html","title":"使用脚手架创建应用","keywords":"","body":"使用脚手架创建应用使用脚手架创建应用 「脚手架」是一种元编程的方法，用于构建基于数据库的应用。许多 MVC 框架都有运用这种思想。 程序员编写一份 specification「规格说明书」，来描述怎样去使用数据库；而由（脚手架的） 编译器来根据这份 specification 生成相应的代码，进行增、删、改、查数据库的操作。 我们把这种模式称为\"脚手架\"，在脚手架上面去更高效的建造出强大的应用。 用过 Django 的读者应该知道，Django 可以利用 manage.py startapp myapp 来生成一个 app 的目录结构，这就是一个脚手架。 同样的 Odoo 也有自己的脚手架，我们可以在命令行运行： $ mkdir Odoo-Book-Demo && cd Odoo-Book-Demo $ ../odoo-bin scaffold bangumi 命令运行后，我们在 odoo-dev 目录下新建了一个 Odoo-Book-Demo 的文件夹，用于存放我们自己开发的 Odoo 应用。 然后利用 Odoo 脚手架 odoo-bin scaffold 命令新建了我们的 bangumi 追番剧应用，我们将它称为 Odoo 的 addon。 我们进入 bangumi 这个目录查看一下目录结构。 $ cd bangumi $ tree . ├── __init__.py ├── __manifest__.py ├── controllers │ ├── __init__.py │ └── controllers.py ├── demo │ └── demo.xml ├── models │ ├── __init__.py │ └── models.py ├── security │ └── ir.model.access.csv └── views ├── templates.xml └── views.xml manifest__mainifest__.py 文件是 addon 的基本信息文件，例如这个 addon 的名称、描述、作者和网站链接等等，这些信息会展现在 addons 的「安装界面」。 controllers用于编写 web 控制器。 demo存放 addon 安装后初始化的 demo 数据的目录。 models用于编写 ORM 数据模型。 security存放权限定义文件的目录。 views存放 addon 的视图的定义文件。 从目录结构可以看出，Odoo 也是标准的 MVC 模式，创建好了应用，接下来我们看看这个应用该如何安装。 "},"Chapter-3/Instaing-Addon.html":{"url":"Chapter-3/Instaing-Addon.html","title":"安装应用","keywords":"","body":"安装应用安装应用 打开 http://localhost:8069，进入 Odoo 就可以看到 Apps 的页面。 但是此时在右上角搜索 bangumi 并不能搜索到我们的 addon， 还需要配置一下 Odoo 的 addons 路径。 打开 Odoo 配置文件 ~/.odoorc 并修改 addons_path，在参数的最后增加你的 Odoo-Book-Demo 的绝对路径，也就是 bangumi 的父路径，用逗号与前路径分隔开。 若已将配置文件复制到 odoo-dev/ 也可以使用相对路径，接下来我们都会使用项目目录下的 odoorc.ini 配置文件，请读者将 ~/.odoorc 复制到 odoo-dev 目录下并重命名为 odoorc.ini。 $ cat ./odoorc.ini ... addons_path = ./addons,./Odoo-Book-Demo ... 就改完后运行 ./odoo-bin -c ./odoorc.ini 重新启动 Odoo，此时我们还需要「刷新本地模块列表」，但是该菜单默认是隐藏的。 我们需要点击所左上角，并点击「设置」到设置页面并点击「激活开发者模式」，再次回到应用页面后就可以看到「刷新本地模块列表」了。 &#x1F4A1; 除了点击「激活开发者模式」可以进入开发者模式外，我们可以通过在 URL 增加 debug 参数来进入开发者模式， 如 http://localhost:8069/web?debug。 刷新本地模块列表后，我们再次搜索，发现依然没有搜索到 bangumi，原因是搜索框中的「应用」过滤把我们的应用给过滤掉了，点击「应用」的「x」将搜索过滤去掉后就可以看到我们的应用了。 但搜索框中将 bangumi 标志为了模块，为了将 bangumi 修改为应用，需要修改 __mainifest__.py 文件。 在 __mainifest__.py 文件中的字典增加 application 并设为 True。 { 'name': \"Bangumi\", 'application': True, # ... } 重启 Odoo 并再次点击 「刷新本地模块列表」后，搜索后可以看到 bangumi 已经被修改为应用了。 最后点击「安装」按钮就可以安装我们的应用了，但是安装后并不会有什么新的菜单或功能，所以接下来进入我们的开发章节。 "},"Chapter-4/Odoo-Model.html":{"url":"Chapter-4/Odoo-Model.html","title":"模型 Model","keywords":"","body":"模型 Model模型 Model 这一章节开始，我们将正式进入 Odoo 应用的开发阶段，依照我们的思维导图中的 Bangumi 应用的功能来 设计数据模型，以此来熟悉 Odoo 中的 ORM，以及 Odoo 中的一些特殊字段定义。 "},"Chapter-4/Model.html":{"url":"Chapter-4/Model.html","title":"定义数据模型","keywords":"","body":"定义数据模型定义数据模型 进入到 bangumi 应用的开发目录。 为了保证项目结构，我们首先删除 models 下的 models.py，新建一个 bangumi.py 来编写第一个模型。 models ├── __init__.py └── bangumi.py 在编写 ORM 模型之前先讲一下 Odoo 在定义模型时常用的三个模块。 models 包含 Model 基础类，用于定义 ORM 模型。 fields 包含模型定义时使用的基础字段，例如 fields.Char、fields.Integer 和 fields.Boolean 等等。 api 包含了数据库环境 Environment 类和一些常用的模型函数装饰器例如 api.multi、api.one 和 api.model 等等。 我们先在文件头部引入这三个模块，然后开始定义第一个模型。 from odoo import models, fields, api class Bangumi(models.Model): _name = 'bangumi.bangumi' _description = 'Bangumi' 我们的模型类的类属性定义了，_name 和 _description 分别是这个模型类的名称和描述。 定义 _name 是要遵守一个不成文的规定，格式一般为 {addon_name}.{model_name} 其中 addon_name 为你的应用或模块的名字，model_name 为模型的名字，例如： project 模块中的 Project 模型的 _name 为 project.project，hr 模块中 LeaveReport 则为 hr.leave.report，以上均参考至官方应用中的模型。 接下来定义模型字段，先定义名称、总集数、当前已看集数和评分字段。 class Bangumi(models.Model): _name = 'bangumi.bangumi' _description = 'Bangumi' name = fields.Char(string='Name', required=True) total = fields.Integer(string='Total', required=True) already_seen = fields.Integer(string='Already seen', default=0) score = fields.Float(string='Score', required=True, default=0.0) 接下来会简单介绍一下这个数据模型在数据库表中会有什么样的对应关系。 我们在定义 name 字段使用了 fields.Char 相当于在 「bangumi.bangumi」所对应的数据库表 「bangumi_bangumi」定义了一个 name 的列，类型为 varchar，用于存放字符串，并且使用 required=True，将该列设置为不可为空。另外两种 fields.Integer 和 fields.Float 也是类似的道理。其次每个 field 的 string 属性是用于在视图中做字段名称的显示，同时会在数据库定义中作为 COMMENT 来解释字段的意义。 在字段定义中我们还利用了 default 属性设置了数据在创建时的默认值。 ⚠️ 这里要注意的是我们在 ORM 设置的 default 值并不会写入数据库表的定义中，如果在数据库中直接插入数据，这个默认值不会生效，必须要通过 ORM 的方式写入数据，默认值才会生效。 定义好模型后我们需要在 models/__init__.py 引入这个类或这个类所在的 py 文件。 from . import bangumi 然后我们需要重启我们的 Odoo 然后进入到应用中点击右上角的按钮并选择「升级」。 接下来如何验证我们的模型是否生效呢？当然可以通过查询数据库的方式，但是 Odoo 提供了另一种方式。 进入「设置」页面，激活「开发者模式」后，点击「技术」菜单并选择「数据库结构」下的「模型」进入模型列表。 搜索 bangumi 就可以看到我们定义的模型，点击可以进入查看模型定义的详细信息。 可以从这个表单看出，除了我们自己定义的模型外，Odoo 还帮我们自动生成了一些常用的字段，例如：create_date、create_uid 和 write_date 等，这些字段可以直接使用，所以需要记住这个特性，防止我们在定义模型时重复定义这些字段。 "},"Chapter-4/Common-ORM-methods.html":{"url":"Chapter-4/Common-ORM-methods.html","title":"常用的 ORM 方法","keywords":"","body":"常用的的 ORM 方法常用的的 ORM 方法 既然使用了 ORM 来定义数据模型，那么如何来操作数据呢？这就要用到 Odoo ORM 的方法，接下来介绍几个常用的 ORM 方法。 在介绍这些方法之前，我们需要进入 Odoo 的交互式命令行，进入 odoo_dev 目录并输入以下命令： $ ./odoo-bin shell -c ./odoorc &#x1F4A1; 建议在使用 Odoo 交互式命令行之前安装 IPython，方便进行代码补全和使用。 ⚠️ 进入命令行前必须将配置文件的 db_name 参数配置成安装了 bangumi 应用相同的数据库，或使用 -d 参数指定数据库。 在上一章节有提到 api 模块中的 Environment 类，我们就是要用这个初始化出一个 env 来操作数据库，不过 Odoo 已经在启动命令行时帮助我们将这个 env 初始化好了。 In [1]: env Out[1]: 我们可以利用 env 来得到我们的数据库模型，并且操作数据库表。 In [2]: env['bangumi.bangumi'] Out[2]: bangumi.bangumi() 接下来我们将利用以下常见的 ORM 方法来操作我们的数据模型。 ⚠️ 在 Odoo 交互式命令行中对数据进行，创建、修改和删除后必须要执行 env.cr.commit() 才会将数据操作写入数据库中。 create() create 方法用于创建模型数据，参数可以为 dict 或 list 类型，创建后会返回创建的记录或记录集。 In [3]: env['bangumi.bangumi'].create({'name': 'Fate', 'total': 24}) Out[3]: bangumi.bangumi(1,) In [4]: env['bangumi.bangumi'].create([{'name': 'SAO', 'total': 24}, {'name': 'Jojo', 'total': 24}]) Out[4]: bangumi.bangumi(2, 3) In [5]: env.cr.commit() search() search 方法用于搜索已存在的数据，与大多数 ORM 框架不同，Odoo 搜索时传入的是一个 domain，它是一个列表形式的参数，在后面的章节会详细介绍这里先不做讲解。 除了 domain 参数，还有 offset、limit、order 和 count，这些都是可选字段。 In [6]: env['bangumi.bangumi'].search([('name', '=', 'Fate')]).name Out[6]: 'Fate' In [7]: env['bangumi.bangumi'].search([('total', '=', 24)], limit=2) Out[7]: bangumi.bangumi(1, 2) In [8]: env['bangumi.bangumi'].search([]) Out[8]: bangumi.bangumi(1, 2, 3) write() write 方法用于修改数据，传入参数为 dict 类型，修改后会返回布尔值 True。 In [9]: env['bangumi.bangumi'].search([('name', '=', 'SAO')]).write({'total': 12}) Out[9]: True In [10]: env.cr.commit() browse() browse 方法可以通过 id 直接返回数据或结果集，参数可以为 dict 或 list 类型。 In [11]: env['bangumi.bangumi'].browse(1) Out[11]: bangumi.bangumi(1,) In [12]: records = env['bangumi.bangumi'].browse([1, 2, 3]) In [13]: records Out[13]: bangumi.bangumi(1, 2, 3) unlink() unlink 方法用于用于删除数据或结果集，删除后返回布尔值 True，结果集可以为空，相当于没有操作。 In [14]: env['bangumi.bangumi'].search([{'name': 'Jojo'}]).unlink() Out[14]: True In [15]: env.cr.commit() exists() exists 用于过滤出数据库中确实存在的数据，这个用法比较奇特需要注意一下。 在上文中我们用 browse 方法搜索出了记录集 records。 In [16]: records Out[16]: bangumi.bangumi(1, 2, 3) 但是实际上 id 为3的数据已经被我们删除了，我们一般会觉得需要重新使用 search 方法搜索数据，这里我们可以利用 Odoo 的 exists 方法，他只会返回数据库中存在的数据或记录集。 In [17]: records.exists() Out[17]: bangumi.bangumi(1, 2,) 利用这个函数我们可以在删除了一些数据后，用于判断数据或记录集是否为空。 if not records.exists(): # do something ... pass &#x1F4A1; 搜索到的记录集中的数字代表记录的 id。 "},"Chapter-4/Many2one-Field.html":{"url":"Chapter-4/Many2one-Field.html","title":"Many2one 多对一字段","keywords":"","body":"Many2one 多对一字段api.model 装饰器Many2one 多对一字段 上一章介绍了 Odoo ORM 一些常用的方法，这一章节继续完善我们的模型。 为给我们的番剧进行分类，我们需要定义一个 Category (类别) 的模型，同样的在 models 目录下新建 category.py文件，并定义 Category 模型。 from odoo import models, fields, api class Category(models.Model): _name = 'bangumi.category' _description = 'Bangumi category' @api.model def _get_current_uid(self): return self.env.uid name = fields.Char(string='Name', required=True) user_id = fields.Many2one( 'res.users', string='User', required=True, default=_get_current_uid ) 首先这个 Category 模型拥有一个 name 字段，其次这个类是某个用户创建的，所以我们给他加个 user_id 字段。 ⚠️ 注意这里也有一个不成文的规定，所有 Many2one (多对一字段，也叫外键字段) 的字段命名后缀应为 _id，例如：partner_id, message_id 等。 这里用了个 Many2one 字段关联到 Odoo 的用户模型 res.users，这是一个很常用的模型要牢记。定义 Many2one 字段除了需要指明关联的模型外，还有一个参数叫 ondelete，它指明了「当关联的用户删除后」当前的模型应该做什么操作。ondelete 主要有以下几个值： set null 当用关联用户删除后，user_id 字段设置为空。 restrict 限制关联的用户删除，当用户被删除时会提示报错。 cascade 级联删除，当用户删除时，将关联的 categroy数据删除。 ⚠️ 使用这种模式时要严格考虑数据的重要性，最好不要随便使用。 api.model 装饰器 除了上文提到的部分，我们还给 user_id 字段定义了一个 default 值，他对应到一个 _get_current_uid 的函数，这个函数的返回值是当前操作这个模型的用户 id。 这里给 _get_current_uid 使用了一个 api.model 装饰器，它是 api 模块中最常见的三大装饰器之一。源码中给这个装饰器的注释是： &#x1F4A1; 常见的装饰器 api.model、api.multi 和 api.one 后文中会提到，感兴趣的可以阅读 Odoo 的 odoo.api 源码。 Decorate a record-style method where self is a recordset, but its contents is not relevant, only the model is. Such a method:: @api.model def method(self, args): ... may be called in both record and traditional styles, like:: # recs = model.browse(cr, uid, ids, context) recs.method(args) model.method(cr, uid, args, context=context) Notice that no ids are passed to the method in the traditional style. 大致意思是这个装饰器装饰了一个方法，这个方法跟数据集 self 本身无关，跟这个模型有关。 这里首先提到了 self 是个数据集，这个一定要弄明白。相当于我们在 ORM 类下定义的方法，它传入的 self 对象除了具有类的特点，他还是一个数据集。 我们引入 logging 模块并在 _get_current_uid 输出 self 的内容： import logging from odoo import models, fields, api _logger = logging.getLogger(__name__) class Category(models.Model): _name = 'bangumi.category' _description = 'Bangumi category' @api.model def _get_current_uid(self): _logger.info(\"Category model call _get_current_uid(%s)\" % self) return self.env.uid 我们先在 models/__init__.py 加入 import . from category 来引入这个模型，然后进入 Odoo 命令行。 ⚠️ 注意此时进入命令行需要增加 -u bangumi 参数，这个参数的意义是在启动时升级 bangumi 模块，这样就不用进入到模块升级页面升级，这个参数非常的常用要牢记。 $ ./odoo-bin shell -c odoorc.ini -u bangumi 然后利用 env 调用 bangumi.category 模型的 _get_current_uid 函数： In [1]: category_model = env['bangumi.category'] In [2]: category_model._get_current_uid() 2019-01-14 14:03:41,197 59965 INFO odoo odoo.addons.bangumi.models.category: Category model call _get_current_uid(bangumi.category()) Out[2]: 1 接下来创建分别两个类别，然后在调用 _get_current_uid 函数： In [3]: movie = category_model.create({'name': 'Movie'}) 2019-01-14 14:07:40,491 59965 INFO odoo odoo.addons.bangumi.models.category: Category model call _get_current_uid(bangumi.category()) In [4]: anime = category_model.create({'name': 'Anime'}) 2019-01-14 14:08:07,610 59965 INFO odoo odoo.addons.bangumi.models.category: Category model call _get_current_uid(bangumi.category()) In [5]: env.cr.commit() In [6]: movie._get_current_uid() 2019-01-14 14:08:57,779 59965 INFO odoo odoo.addons.bangumi.models.category: Category model call _get_current_uid(bangumi.category(1,)) Out[6]: 1 In [7]: anime._get_current_uid() 2019-01-14 14:09:13,070 59965 INFO odoo odoo.addons.bangumi.models.category: Category model call _get_current_uid(bangumi.category(2,)) Out[7]: 1 In [8]: category_model.search([])._get_current_uid() 2019-01-14 14:09:44,073 59965 INFO odoo odoo.addons.bangumi.models.category: Category model call _get_current_uid(bangumi.category(1, 2,)) Out[8]: 1 可以看到 self 可以为 单个记录 也可以为 多个记录，这一点要注意。 回到正题，api.model 这个装饰器到底什么时候该用呢，其实按照代码注释的意思很容易理解，你可以这么理解记忆，当你认为这段代码跟 self 中的数据无关时，就加上 @api.model 装饰器，是不是有点像类中的类方法。 再来看看我们的函数返回值，这里调用了 self.env.uid 其中的 env 就是我们的数据库环境，你可以尝试在交互式命令行中直接调用 env.uid 或 env.user，他会返回当前的默认 admin 的 id 或 admin 用户对象，而在模型中则为当前操作这个数据或对象的用户。 In [9]: env.uid Out[9]: 1 In [10]: env.user Out[10]: res.users(1,) 定义完 Category 模型，我们就可以在 Bangumi 中增加分类字段进行外键关联了。 class Bangumi(models.Model): _name = 'bangumi.bangumi' _description = 'Bangumi' name = fields.Char(string='Name', required=True) total = fields.Integer(string='Total', required=True) already_seen = fields.Integer(string='Already seen', default=0) score = fields.Float(string='Score', required=True, default=0.0) category_id = fields.Many2one( 'bangumi.category', string='Category', required=False ) "},"Chapter-4/One2many-Field.html":{"url":"Chapter-4/One2many-Field.html","title":"One2many 一对多字段","keywords":"","body":"One2many 一对多字段One2many 一对多字段 上一章定义了 Many2one 字段，将 Bangumi 与 Category 相关联。 class Bangumi(models.Model): _name = 'bangumi.bangumi' _description = 'Bangumi' name = fields.Char(string='Name', required=True) total = fields.Integer(string='Total', required=True) already_seen = fields.Integer(string='Already seen', default=0) score = fields.Float(string='Score', required=True, default=0.0) category_id = fields.Many2one( 'bangumi.category', string='Category', required=False ) 我们先进入交互式命令行将之前创建的数据于类别关联起来，同样的启动时别忘了 -u bangumi 参数，因为模型变更了。 $ ./odoo-bin shell -c odoorc.ini -u bangumi ... In [1]: anime = env['bangumi.category'].search([('name', '=', 'Anime')]) In [2]: anime Out[2]: bangumi.category(2,) In [3]: env['bangumi.bangumi'].search([]).write({'category_id': anime.id}) Out[3]: True In [4]: env.cr.commit() 访问一下 bangumi 的 category_id 字段看看关联是否成功了。 In [8]: bangumi = env['bangumi.bangumi'].search([], limit=1) In [9]: bangumi.category_id.name Out[9]: 'Anime' 可以看到 category_id 字段已经成功关联了，那么我们怎么从 Anime 这个类别访问到它底下的所有 bangumi 呢？ 这时候就需要在 Category 模型下定义一个 One2Many 字段来反向关联到 Bangumi 模型。 class Category(models.Model): _name = 'bangumi.category' _description = 'Bangumi category' @api.model def _get_current_uid(self): _logger.info(\"Category model call _get_current_uid(%s)\" % self) return self.env.uid name = fields.Char(string='Name', required=True) user_id = fields.Many2one( 'res.users', string='User', required=True, default=_get_current_uid ) bangumi_ids = fields.One2many( 'bangumi.bangumi', 'category_id', string='Category Bangumi Set' ) 这个字段的第一个属性是反向关联的模型，也就是 bangumi.bangumi。第二个字段是当前模型在反向关联的模型中定义为哪个字段，我们定义的是 category_id 字段。 ⚠️ 这里依然要注意字段的命名，Odoo 中的 One2many 字段名称请以 _ids 结尾。 再次进入命令行： $ ./odoo-bin shell -c odoorc.ini -u bangumi ... In [1]: anime = env['bangumi.category'].search([('name', '=', 'Anime')]) In [2]: anime.bangumi_ids Out[2]: bangumi.bangumi(1, 2) "},"Chapter-4/Many2many-Field.html":{"url":"Chapter-4/Many2many-Field.html","title":"Many2many 多对多字段","keywords":"","body":"Many2Many 多对多字段Many2Many 多对多字段 为了能给 Bangumi 打标签，我们还需要一个 Tag 模型，同样的在 models 下新建 tag.py，并且定义 Tag 模型。 class Tag(models.Model): _name = 'bangumi.tag' _description = 'Bangumi tag' name = fields.Char(string='Name', required=True) user_id = fields.Many2one( 'res.users', string='User', required=True, default=lambda self: self.env.uid ) 别忘了将在 models/__init__.py 中加入 from . import tag。 这次的 user_id 的默认值我们使用 lambda 函数来简化我们的代码。 由于 Bangumi (番剧) 与 Tag (标签) 是多对多的关系，所以需要用到 Many2many 字段。 我们分别在两个模型上都加上，Many2many (多对多) 字段。 class Bangumi(models.Model): _name = 'bangumi.bangumi' _description = 'Bangumi' name = fields.Char(string='Name', required=True) total = fields.Integer(string='Total', required=True) already_seen = fields.Integer(string='Already seen', default=0) score = fields.Float(string='Score', required=True, default=0.0) category_id = fields.Many2one( 'bangumi.category', string='Category', required=False ) tag_ids = fields.Many2many( 'bangumi.tag', 'bangumi_bangumi_tag_rel', 'bangumi_id', 'tag_id', string='Bangumi Tags' ) class Tag(models.Model): _name = 'bangumi.tag' _description = 'Bangumi tag' name = fields.Char(string='Name', required=True) user_id = fields.Many2one( 'res.users', string='User', required=True, default=lambda self: self.env.uid ) bangumi_ids = fields.Many2many( 'bangumi.bangumi', 'bangumi_bangumi_tag_rel', 'tag_id', 'bangumi_id', string='Tag Bangumi Set' ) ⚠️ Many2many 的字段命名规则与 One2many 命名规则相同，名称都是以 _ids结尾。 Many2many 主要由以下几个属性组成： 目标模型 建立多对多关系的目标模型。 多对多关系名称 与目标模型建立的多对多关系名称，这个名称会在数据库中生成对应的表，所以命名时要注意以模块名称 + _下划线开头。 关系中自身代表的字段 这个字段名称会在关系数据表中生成，代表当前模型数据的 id。 关系中代表目标的字段 这个字段名称会在关系数据表中生成，代表目标模型数据的 id。 接下来还是进入到命令行中验证我们定义的 Many2many 字段，首先创建一些数据： In [2]: tags = env['bangumi.tag'].create([{'name': 'warm blood'}, {'name': 'science fiction'}, {'name': 'fight'}]) In [3]: tags Out[3]: bangumi.tag(1, 2, 3) 接下来我们将数据写入： In [2]: tags = env['bangumi.tag'].create([{'name': 'warm blood'}, {'name': 'science fiction'}, {'name': 'fight'}]) In [3]: tags Out[3]: bangumi.tag(1, 2, 3) In [4]: bangumi_set = env['bangumi.bangumi'].search([]) In [5]: bangumi_set Out[5]: bangumi.bangumi(1, 2) In [6]: bangumi_set.write({'tag_ids': tags.ids}) Out[6]: True In [7]: bangumi_set.ids Out[7]: [1, 2] In [8]: env.cr.commit() In [9]: bangumi_set[0].tag_ids Out[9]: bangumi.tag() In [10]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[10]: [] ⚠️ 注意这种写法在 Odoo 10 会直接报错，Odoo 12 并没有抛出异常，但是数据依然无法写入。 可以发现数据根本没有写进去，这是为什么呢？查看以下官方对 Many2many 字段的描述： One2many and Many2many use a special “commands” format to manipulate the set of records stored in/associated with the field. This format is a list of triplets executed sequentially, where each triplet is a command to execute on the set of records. Not all commands apply in all situations. Possible commands are: (0, _, values) adds a new record created from the provided value dict.(1, id, values)updates an existing record of id id with the values in values. Can not be used in create().(2, id, _)removes the record of id id from the set, then deletes it (from the database). Can not be used in create().(3, id, _)removes the record of id id from the set, but does not delete it. Can not be used on One2many. Can not be used in create().(4, id, _)adds an existing record of id id to the set. Can not be used on One2many.(5, , )removes all records from the set, equivalent to using the command 3 on every record explicitly. Can not be used on One2many. Can not be used in create().(6, _, ids)replaces all existing records in the set by the ids list, equivalent to using the command 5 followed by a command 4 for each id in ids.Values marked as _ in the list above are ignored and can be anything, generally 0 or False. 从文档中的描述中可以看出，不止是 Many2many 字段，包括 One2many 字段在写入操作时都比较特殊。总的来说一共有7总格式： (0, _, values) 增加一条未创建的数据到 X2many 字段中，并且以 value 字典中的值作为这个新数据的值。其中下划线的值可以为 0 或 False。 In [11]: bangumi_set[0].write({'tag_ids': [(0, 0, {'name': 'magic'})]}) Out[11]: True In [12]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[12]: ['magic'] (1, id, values) 更新一个已经存在的并且关联的值的数据，不能用在 create 方法中。 In [13]:bangumi_set[0].tag_ids.id Out[13]: 4 In [14]: bangumi_set[0].write({'tag_ids': [(1, 4, {'name': 'Magic'})]}) Out[14]: True In [15]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[15]: ['Magic'] (2, id, _) 移除一个已经关联的数据，并且将这条数据从数据库中删除，不能用在 create 方法中。 In [16]: bangumi_set[0].write({'tag_ids': [(2, 4, 0)]}) 2019-01-14 16:27:30,601 62971 INFO odoo odoo.models.unlink: User #1 deleted bangumi.tag records with IDs: [4] Out[16]: True In [17]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[17]: [] (3, id, _) 移除一个已经关联的数据，但不将这条数据从数据库中删除，不能用在 create 方法中。 In [18]: bangumi_set[0].write({'tag_ids': [(0, 0, {'name': 'magic'})]}) Out[18]: True In [19]: bangumi_set[0].tag_ids.id Out[19]: 5 In [20]: bangumi_set[0].write({'tag_ids': [(3, 5, 0)]}) Out[20]: True In [21]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[21]: [] (4, id, _) 增加一个已经创建的数据到 Many2many 字段中，One2Many 不可用。 In [22]: tags = env['bangumi.tag'].search([]) In [23]: tags[0] Out[23]: bangumi.tag(1,) In [24]: bangumi_set[0].write({'tag_ids': [(4, 1, 0)]}) Out[24]: True In [25]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[25]: ['warm blood'] (5, _, _) 移除 Many2many 中的所有关联字段，但是并不从数据库中删除它们，不能用于 One2many 中。 In [26]: tags = env['bangumi.tag'].search([]) In [27]: for tag in tags: ...: bangumi_set[0].write({'tag_ids': [(4, tag.id, 0)]}) ...: In [28]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[28]: ['warm blood', 'science fiction', 'fight', 'magic'] In [29]: bangumi_set[0].write({'tag_ids': [(5, 0, 0)]}) Out[29]: True In [30]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[30]: [] (6, 0, ids) 用新的集合替换已经关联的 Many2many 集合，但不删除旧的数据。 In [31]: bangumi_set[0].write({'tag_ids': [(4, 1, tags[0].id)]}) Out[31]: True In [32]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[32]: ['warm blood'] In [33]: bangumi_set[0].write({'tag_ids': [(6, 0, tags[1:].ids)]}) Out[33]: True In [34]: bangumi_set[0].tag_ids.mapped(lambda r: r.name) Out[34]: ['science fiction', 'fight'] Odoo 的 X2many 字段的写入设计的比较奇特，但是正是这样的设计，使得一对多和多对多字段能够批量进行修改，并且非常的灵活。 "},"Chapter-4/Computed-field.html":{"url":"Chapter-4/Computed-field.html","title":"计算字段","keywords":"","body":"计算字段计算字段 这一章节将介绍 Odoo 中的一个常用特殊的字段类型——计算字段。我们先给 Bangumi 模型增加上映时间和更新周期字段。 class Bangumi(models.Model): _name = 'bangumi.bangumi' _description = 'Bangumi' name = fields.Char(string='Name', required=True) total = fields.Integer(string='Total', required=True) already_seen = fields.Integer(string='Already seen', default=0) score = fields.Float(string='Score', required=True, default=0.0) category_id = fields.Many2one( 'bangumi.category', string='Category', required=False ) tag_ids = fields.Many2many( 'bangumi.tag', 'bangumi_bangumi_tag_rel', 'bangumi_id', 'tag_id', string='Bangumi Tags' ) update_cycle = fields.Selection([ ('weekly', 'Update weekly'), ('monthly', 'Update monthly'), ('quarterly', 'Update quarterly') ], string='Update cycle', required=True, default='weekly') release_date = fields.Date(string='Release date', default=fields.Date.today(), required=True) 其中 update_cycle 使用了一个选择字段，相当于这个字段的值只能是 weekly、monthly 或者 quarterly，并且值所在的元组的第二个元素则是他们具体显示的值。 然后我们在增加一个 current 字段用于显示我们番剧当前已经播放到第几集了。 class Bangumi(models.Model): _name = 'bangumi.bangumi' _description = 'Bangumi' @api.multi @api.depends('release_date', 'update_cycle', 'total') def _compute_current(self): for record in self: today = fields.Date.today() dt = today - record.release_date if dt.days 从代码可以看到，current 字段的设置了一个 compute 属性，并且这个属性指向 _compute_current 函数。 因为当前剧集是通过 release_date (开播时间)，update_cycle (更新周期) 和 total (总集数) 计算而来的，所以在这个函数使用了 api.depends 装饰器，并且入参是前面提到的三个参数。 除了 api.depends 装饰器以外还使用了 api.multi 装饰器，这里是显式的指明 _compute_current 传入的 self 可以为一个记录集，所以在处理时需要循环对 self 中的每一个记录进行处理。api.multi 也是常用的三个装饰器之一，除了 api.multi 还有 api.model 和 api.one，api.model 在前面的章节已经提到过了，这里说明一下 api.one。 api.one 与 api.multi 装饰器类似，但是他将 self 处理成一条记录，也就是我们不需要对 self 进行循环处理。 ⚠️ 函数在不使用这些装饰器时，默认 self 都是记录集，所以要记得对 self 进行循环处理。 回到 compute_current 函数，这个函数主要是 @api.multi @api.depends('release_date', 'update_cycle', 'total') def _compute_current(self): for record in self: today = fields.Date.today() dt = today - record.release_date if dt.days 根据依赖的三个字段计算出 current 当前在播的集数，函数只是个例子，计算的结果不一定准确，读者可以自行优化。 我们进入到命令行中测试一下这个字段，别忘了在 python 虚拟环境中运行： $ ./odoo-bin shell -c odoorc.ini -u bangumi ... In [1]: Bangumi = self.env['bangumi.bangumi'] In [2]: bangumi = Bangumi.search([], limit=1) In [3]: from datetime import datetime, timedelta In [4]: bangumi.write({'release_date': datetime.today() - timedelta(days=14)}) Out[4]: True In [5]: bangumi.current Out[5]: 2 In [6]: env.cr.commit() 计算字段还有一个特殊的属性 store，这个属性默认为 False。若设置为 True 则将会把计算出来的结果存入数据库中，但是他只会在依赖的数据发生变化时将重新计算的字段写入数据库中，但是必须通过 ORM 修改数据才有重新计算，使用 SQL 无效。 "},"Chapter-4/Domain.html":{"url":"Chapter-4/Domain.html","title":"过滤表达式 Domain","keywords":"","body":"过滤表达式 Domain过滤表达式 Domain 在常用的 ORM 方法章节中提到了 search 查询方法，这一章节就大概的讲解一下，Odoo 的 Domain 过滤表达式。 Domain 是一个列表类型的参数，他的每一个元素可以是一个三个元素组成的元组 '(字段名, 运算符, 值)'，或者是 | (或)、 & 运算符, 例如： [（'name' , '=' , 'ABC' ）, （'language.code' , '！=' , 'en_US' ）, '|' , （'country_id.code' , '=' , 'be' ）, （'country_id.code' , '=' , 'de' ）] 也可以写成： [ '|' , （'country_id.code' , '=' , 'be' ）, （'country_id.code' , '=' , 'de' ）, '&', （'name' , '=' , 'ABC' ）, （'language.code' , '！=' , 'en_US' ）, ] 这个 Domain 的意思是，搜索一个名称为 ABC，并且语言不是英语，城市可以是比利时或德国的一条记录。 ⚠️ |、& 运算符需要放在两个条件之前，这点要注意。 这种写法叫波兰表示法有兴趣的可以去了解一下。 运算符可以参考官方文档，这里就不一一举例了。 "},"Chapter-5/Odoo-Menu.html":{"url":"Chapter-5/Odoo-Menu.html","title":"菜单 Menu","keywords":"","body":"菜单 Menu菜单 Menu 这一章节我们要学会如何创建一个应用的菜单，使用菜单来访问我们的应用。 "},"Chapter-5/Creation-Menu.html":{"url":"Chapter-5/Creation-Menu.html","title":"菜单创建","keywords":"","body":"菜单创建菜单创建 在我们的 bangumi 的 addon 目录下有个 views 文件夹，用于放置所有的菜单视图，列表和表单视图等视图的 XML 定义文件。 接下来我们新建一个名为 menus.xml 的文件，并且写入以下代码。 其中我们定义了两个元素： act_window 元素定义了一个客户端窗口操作，它将打开 bangumi.bangumi 模型，并按顺序启用列表，看板和表单视图。 menuitem 定义了一个名 Bangumi 为主菜单，这个菜单会调用前面定义的 act_bangumi_view 动作，并且可以看到这个菜单的权限组为 base.group_user 即已登陆的内部用户。 定义完 views/menus.xml 文件，我们需要将它添加到 __manifest__.py 中，并升级 bangumi 模块使其生效。 { #... # always loaded 'data': [ # 'security/ir.model.access.csv', 'views/views.xml', 'views/templates.xml', 'views/menus.xml', ], #... } 升级模块后发现，Bangumi 菜单并未出现在菜单列表中。这是什么原因导致的呢？ 这就牵扯到 Odoo 的权限控制，由于我们未给 act_window 关联的模型 bangumi.bangumi 设置权限，所以我们无法看到定义好的菜单。 这一章节将不细讲 Odoo 的权限控制，我们现将以下内容复制到 security/ir.model.access.csv 文件内，这是一个 csv 文件，用于控制 Odoo 中定义的模型的权限，这段内容的意思是给我们定义的所有模型为 base.group_user 增加读、写等所有权限。 id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink access_bangumi_bangumi,bangumi.bangumi,model_bangumi_bangumi,base.group_user,1,1,1,1 access_bangumi_category,bangumi.category,model_bangumi_category,base.group_user,1,1,1,1 access_bangumi_tag,bangumi.tag,model_bangumi_tag,base.group_user,1,1,1,1 然后我们再次修改__manifest__.py: { #... # always loaded 'data': [ 'security/ir.model.access.csv', 'views/views.xml', 'views/templates.xml', 'views/menus.xml', ], #... } 再次打开 Odoo 页面就可以看到我们定义的菜单和模型对应的视图了。 ⚠️ 如果说在做完上述步骤后还不能看到菜单，可以尝试 gif 中的步骤，切换客户端语言。 点击右上角用户信息 切换语言后保存 导致这个问题的原因应该是前端缓存了客户端的菜单列表，若有读者通过别的更好的方式解决了这个问题，可以在 issuse 中告诉我们。 "},"Chapter-6/Odoo-View.html":{"url":"Chapter-6/Odoo-View.html","title":"视图 View","keywords":"","body":"视图 View视图 View Odoo 为我们提供了丰富的视图，有列表 List、表单 Form、看板 Kanban 和 日历 Calendar 等等视图，都可以在官方「视图」文档中找到。 本章节我们将学会如何去自定义最常用的列表、表单、搜索视图和看板视图。 "},"Chapter-6/ListView.html":{"url":"Chapter-6/ListView.html","title":"列表视图 ListView","keywords":"","body":"列表视图 List View列表视图 List View 在上一章节中，我们已经为 bangumi 应用创建了入口菜单和菜单对应的动作。如果我们还未给动作对应的模型定义列表视图和表单视图，Odoo 会默认为我们生成列表视图。 默认视图只显示了 Name 字段，显然是不满足我们的需求的，接下来我们需要尝试给对应的模型自定义一个列表视图。 同样的进入 bangumi 模块下的 views 目录，并打开 views.xml。如果没有的话就新建一个 （这里的文件名不一定要使用 views.xml 也可以使用别的。）。 views ├── menus.xml ├── templates.xml └── views.xml 打开之后我们需要在 {在这里定义} 中间定义一个 tree 视图也就是我们的 List View。 tree 视图的定义如下所示： bangumi.list bangumi.bangumi 这里面的数据和结构我大致介绍一下： 第 3 行的 model 属性，定义了这是一个 ir.ui.view 也就是 odoo 的视图，id 属性指名了这个视图的唯一标示，所以在写的时候要注意它的命名和唯一性。如果不知道自己定义的视图 id 该怎么命名，可以参考官方的模块命名格式。 第 4 行的 name 是这个视图的名字，这个没有唯一约束。 第 5 行的 model 指明了这个视图关联的是哪个模型，这里关联的是 bangumi.bangumi 模型。 第 6 行是固定写法，第 7 行和第 17 行的 标签表明了这是一个列表视图。 第 8 行到第 16 行是这个视图需要展示的字段。其中 10 行的 指明了这个字段使用一个叫 many2many_tags 的挂件（widget）来展示（odoo 中还有很多的 widget 这里就不一一介绍了，想了解的可以在官方源码中搜索 widget 关键字）。 视图定义好之后，我们该如何使用呢。在使用之前我先介绍一下 odoo 的菜单、动作和视图的关系。 在上一章节中，我们定义了 menuitem 和 act_window，他们分别代表了菜单和动作。从 menuitem 的定义中有 action 属性这个特点，我们不难看出菜单是入口，它可以关联动作。 那么视图应该关联在哪里呢，有些同学可能觉得是菜单，但视图实际上是要关联动作。因为我们在点击菜单后触发动作，随后跳转到了一个默认的 List View 视图。在 act_window 有一个 view_id 的属性，用于显式指定关联的视图，当然默认是关联这个 act_window 的 model 模型所对应的默认视图。 接下来我们给 act_window 加上 view_id 来显式指定成我们刚刚定义的视图。 然后就可以升级我们的 bangumi 模块看看效果，当然升级之前别忘了检查 __manifest__.py 是否已经包含了我们定义的 xml。 升级完成后重新打开或刷新页面就可以看到效果了。 ⚠️ List View 也叫 Tree View，后文所有提到 Tree 视图的部分就是列表视图。 "},"Chapter-6/FormView.html":{"url":"Chapter-6/FormView.html","title":"表单视图 FormView","keywords":"","body":"表单视图 Form View表单视图 Form View 上一节我们自定义了一个列表视图，那么我们可以创建一个数据试试效果了。 那么可以点击左上角的「创建」按钮进入用于数据创建的 Form View （表单视图）。 这个 Form 视图也是 odoo 默认生成的视图。在创建数据之前，我们也将这个视图定义一下吧。 Form 视图定义的位置跟 Tree 视图定义的位置一样，这里就不讲整个文件贴出来了，只贴 Form 视图定义的部分。 bangumi.form bangumi.bangumi 与 Tree 视图不同的是 修改为了 。其他部分大致相同，这里就介绍一下不同的地方。 第 6 行和第 20 行的 的作用是给表单提供一个「卡片」，效果如下图所示。你也可以尝试去掉这个标签对比一下有什么不同。 第 7 行和第 12 行、第 13 行和 第 19 行的 作用是给字段分组和提供前面的字段称显示。同样你可以尝试去掉这个标签对比一下有什么不同。 创建并更新完成后，最终效果就跟上面的截图一样了。这里并没有将 form 关联到 act_window，因为创建后的`form 就成为了 model 的默认表单，所以可以直接生效，当然 tree 视图也是一样的，上一节为了演示可以显式指定 view_id 当然不指定也是可以生效的。 当然 form 也可以显试指定，在 act_window 中的字段为 view_ids，它的指定方式比较特殊，需要使用波兰表达式，在官方的源码全局搜索 view_ids 可以查看示例，这里就不演示了。 接下来我们来尝试创建一条数据，这里我创建了一个 《刀剑神域 Alicization篇 War of Underworld》的数据，你们也可以自行创建自己喜欢的番剧，记得点击保存。 创建过程中你肯定会发现，Category 和 Bangumi Tags 的创建表单也是默认生成的，当然你们也可以通过上面的方式去定义他们的 form 视图。 最后数据创建的效果如下。 我们可以发现原本没有填写的 Current 值自动生成了，这就是在 model 中定义的 compute 字段起的作用。 "},"Chapter-6/SearchView.html":{"url":"Chapter-6/SearchView.html","title":"搜索视图 SearchView","keywords":"","body":"搜索视图 Search View搜索视图 Search View 上一节我们介绍了如果自定义 Form 表单，并且创建了数据。这里我又创建多了两条数据，在 Tree 视图的效果如下。 是不是已经有一点基本的样子了，让我们继续完善它。一个 Web 服务最重要的搜索功能不能少，当数据多的时候可以方便数据检索，接下来我们就完善它的搜索功能。 odoo 虽然默认支持搜索，但是搜索功能很不友好，在输入提示这里也只有 Name 字段做了搜索提示。当然你也可以点击筛选做更高级的搜索，但是搜索这种重复使用的功能如果操作复杂就不好用了。 所以接下来我们要使用 Search View （搜索视图）来完善搜索功能。同样的我们需要在 views.xml 下定义该视图，以下是定义。 bangumi.search bangumi.bangumi Search View 与之前的定义不同的地方也是 ，然后需要在 标签中间添加你需要搜索提示的字段。Odoo 默认会使用这些字段的 name 字段作为搜索，当然一些情况下你可能不一定以外键字段的 name 字段作为搜索条件，这时候你就需要显式指定了。 bangumi.search bangumi.bangumi filter_domain 为你定义的搜索条件，可以参考这个章节 过滤表达式 Domain，其中 self 表示用户传入的搜索值，如用户搜索 2019 则 self 的值就为 2019。 更新一下应用并刷新页面看一下效果。 "},"Chapter-6/KanbanView.html":{"url":"Chapter-6/KanbanView.html","title":"看板视图 KanbanView","keywords":"","body":"看板视图 Kanban View看板视图 Kanban View 很多时候我们会在一些站点上看到这样的页面。每个列表中的元素都以图片和文字的形式，以横向和竖向排列，这就是「看板」。 接下来我们会用 Odoo 中的 Kanban View 来实现这种效果。 首先我们先给我们的模型增加封面图片字段吧，将字段定义到 bangumi.bangumi 模型中，字段定义如下。 cover_image = fields.Binary(string='Cover image', attachment=True) 然后需要到 views.xml 给我们的 Form 视图增加一个字段用于显示和编辑封面字段。 更新后，并上传封面图片后的表单效果如下。 接下来在 views.xml 中定义我们的 Kanban View。 Kanban View 的结构与其他的视图有一些不同，先放出 Kanban View 的完整定义。 bangumi.kanban bangumi.bangumi 首先我们需要定义 Kanban 视图，这个跟前面的视图定义方式很类似。 bangumi.kanban bangumi.bangumi 需要列出你要使用的 field 字段，这个很重要！ 这一步与其他视图有些不同，需要定义一个 ，这里先提前告诉你这是 Odoo 的一种模板语法叫做 QWeb。他与普通的 HTML 语法很类似，但是可以穿插逻辑语句交给后段执行并渲染，这里就不做详细介绍了，后面章节会详细介绍。 这里要提一下 QWeb 中的 img 标签，他必须包含 alt 属性，否则会报错。它可以通过 t-att-src 属性设置需要渲染的图片。如果你需要渲染的图片来自具体的数据记录，你需要使用 kanban_image 函数。 其中 kanban_image 有三个参数。第一个参数是具体的模型，这里为 bangumi.bangumi。第二个参数是图片所对应的字段，前面我们定义的字段是 cover_image。最后一个参数注意了是这个数据的 id 值，我们需要在第二部明确列出我们需要使用 id 字段才能在这里使用，否则会报错，这里要获取到 id 具体的值需要填写 record.id.raw_value。 更新完成并刷新页面的，然后点击右上角的切换按钮，效果如下图所示。 "},"Chapter-6/Summary.html":{"url":"Chapter-6/Summary.html","title":"小结","keywords":"","body":"第六章 小结第六章 小结 这一章虽然内容不算太多，但是还是需要做个小结。因为 Odoo 的视图是 Odoo 非常的优秀的设计之一，而且内容也很多，还有非常多的视图没有介绍。 虽然内容非常多，但是官方文档非常介绍的非常的少。这里就需要同学们自行阅读 Odoo 的源码，不断的尝试。作者本人也是在不断尝试过程中才完成 Kanban 视图这一章节。 Odoo 的源码写的非常详细，它的源码就是最好的文档，不要害怕阅读源码，它会给你开启一扇新世界的大门。 "},"Chapter-7/Odoo-Action.html":{"url":"Chapter-7/Odoo-Action.html","title":"动作 Action","keywords":"","body":"动作 Action动作 Action 前面的几个章节带着大家一起创建了一个属于自己的 Odoo 应用。你肯定有很多疑惑，为什么要定义那么多的 XML？他们到底用来做什么的？定义的 XML 还可以增加什么参数？这么多的 XML 写法我应该怎么去记忆？ 这一章节带同学们从 Odoo 的 Action，来解开上面的疑惑，并且同时学习 Odoo 的 Action。 Action 是 Odoo 的重要组成部分之一，学习并了解他有助于我们实现各种各样的功能。 Odoo 中我们常用的动作有窗口动作、服务器动作、 和 客户端动作。接下来就带大家一个一个了解它们。 "},"Chapter-7/Action-Window.html":{"url":"Chapter-7/Action-Window.html","title":"窗口动作","keywords":"","body":"窗口动作在 Odoo 中查看 \"窗口动作\" 的数据窗口动作 在第 5 章和第 6 章我们都使用到了一个 act_window 的标签定义在 menus.xml 中。 这就是一个窗口动作的定义。他还有另一种定义的写法。 Bangumi bangumi.bangumi tree,kanban,form 是不是一下子就头大了，本来定义这个 XML 就不好记忆，为啥又多了一种写法。我该怎么记？ 在回答你的疑惑之前，我们先来了解一下 Odoo 定义的 XML 最终都去了哪里？ 其实在 XML 中定义的 标签指明了这是一条数据记录，最终他都会保存到数据库，而且这条记录也拥有 Model，也就是在 python 代码中也有跟我们在第 4 章定义的类一样的结构。那我们可以在哪里找到上面的 record 对应的 Model 呢？ 细心的同学肯定已经发现了，record 标签有一个 model 字段，已经告诉了你它对应的 model 是 ir.actions.act_window。 接下来我们就可以利用这个关键字和全文检索在 Odoo 的源码中找到他。 &#x1F4A1; 可能很多人还不知道怎么做全文检索，这里简单说一下。如果你是用的是 Pycharm，可以点击 Odoo 源码文件夹的主目录，右键选择 Find in Path 或者使用快捷键 ctrl + shift + F （command + shift + F）进行全文检索。如果你是用的是 Vscode 可以使用快捷键 ctrl + shift + F （command + shift + F）进行全文检索。其他工具请在搜索引擎搜索使用方法。 由于直接搜索 ir.actions.act_window 出现的关键字可能比较多，我们使用 _name = 'ir.actions.act_window' 关键字进行搜索。 用这个关键字搜索后，你可能就直接找到了这个模型的定义，模型的部分定义如下。 class IrActionsActWindow(models.Model): _name = 'ir.actions.act_window' _description = 'Action Window' _table = 'ir_act_window' _inherit = 'ir.actions.actions' _sequence = 'ir_actions_id_seq' _order = 'name' # ... 我们可以从上面部分定义看到一个 _table 的属性，这个字段显式指定了这个模型对应数据库表是 ir_act_window。这里也提一下，如果这个字段没有显式指定的话，默认使用的表名是 _name 字段将 . 全部替换成 _ 后的字符串，如 bangumi.bangumi 则对应的表名为 bangumi_bangumi。 我们也可以从源码中看到这个模型定义的字段。 # 省略代码 ... name = fields.Char(string='Action Name', translate=True) # 省略代码 ... view_id = fields.Many2one('ir.ui.view', string='View Ref.', ondelete='set null') # 省略代码 ... src_model = fields.Char(string='Source Model', help=\"Optional model name of the objects on which this action should be visible\") # 省略代码 ... view_mode = fields.Char(required=True, default='tree,form', help=\"Comma-separated list of allowed view modes, such as 'form', 'tree', 'calendar', etc. (Default: tree,form)\") 我们正好可以找到 标签中 对应的四个关键字 name、res_model、view_mode 和 view_id。 Bangumi bangumi.bangumi tree,kanban,form 由此我们可以猜测 Odoo 将我们在 XML 中定义的 record 当成数据，按照对应的模型和数据库表，写入了数据库中。我们可以用以下 SQL 验证一下。 psql -h 127.0.0.1 -U odoo Password for user odoo: psql (9.6.15) Type \"help\" for help. odoo=# select name, res_mode, view_mode, view_id FROM ir_act_window where name='Bangumi'; name | res_model | view_mode | view_id ---------+-----------------+------------------+--------- Bangumi | bangumi.bangumi | tree,kanban,form | 233 (1 row) 在 Odoo 中查看 \"窗口动作\" 的数据 除了用 SQL，Odoo 提供了另一种更加方便的方式查看这些数据。首先打开 debug 模式，不记得 debug 模式怎么打开可以查看第 3 章 \"安装应用\" 章节。 打开后点击左上角并选择「设置」，进入设置页面。然后在点击上方的「技术」菜单，选择「动作」下的「窗口动作」，就可以看到所有窗口动作的列表了。 从列表我们就可以看到我们定义的 Bangumi 动作，如果没找见的话可以用右上角的搜索功能。接下来我们点击这行记录到 Form 视图看看。 所以可以通过上述方式来查看自己定义的 Action 的属性。 &#x1F4A1; 可以通过将鼠标悬停在字段的名称上查看字段定义的详细信息。 "},"Chapter-7/Action-Server.html":{"url":"Chapter-7/Action-Server.html","title":"服务器动作","keywords":"","body":"服务器动作服务器动作 接下来介绍服务器动作，这个也是开发过程中很常用的动作，它可以让 odoo 服务执行一段代码，并且它也可以绑定按钮或菜单，我们来动手实现一下。 假设我们需要实现一个这样的功能，在 bangumi 模型增加一个 like 字段，然后我们就可以给我们添加的番剧点赞，但是有时候需要在列表页批量操作。 我们先给对应的模型、tree 视图和 form 视图增加 like 字段。 like = fields.Boolean(string='Like', default=False) 然后在给 bangumi.bangumi 模型增加 action_like 和 action_unlike 两个函数。 class Bangumi(models.Model): _name = 'bangumi.bangumi' _description = 'Bangumi' @api.multi def action_like(self): return self.write({'like': True}) @api.multi def action_unlike(self): return self.write({'like': False}) 最后就是定义这个 服务器动作，在定义之前我们先看看这个服务器动作的模型定义，我们可以通过源码全文搜索 _name = 'ir.actions.server 找到这个模型。 class IrActionsServer(models.Model): # 省略代码 ... _name = 'ir.actions.server' _description = 'Server Actions' _table = 'ir_act_server' _inherit = 'ir.actions.actions' _sequence = 'ir_actions_id_seq' _order = 'sequence,name' # 省略代码 ... state = fields.Selection([ ('code', 'Execute Python Code'), ('object_create', 'Create a new Record'), ('object_write', 'Update the Record'), ('multi', 'Execute several actions')], string='Action To Do', default='object_write', required=True, help=\"Type of server action. The following values are available:\\n\" \"- 'Execute Python Code': a block of python code that will be executed\\n\" \"- 'Create or Copy a new Record': create a new record with new values, or copy an existing record in your database\\n\" \"- 'Write on a Record': update the values of a record\\n\" \"- 'Execute several actions': define an action that triggers several other server actions\\n\" \"- 'Add Followers': add followers to a record (available in Discuss)\\n\" \"- 'Send Email': automatically send an email (available in email_template)\") # 省略代码 ... model_id = fields.Many2one('ir.model', string='Model', required=True, ondelete='cascade', help=\"Model on which the server action runs.\") model_name = fields.Char(related='model_id.model', string='Model Name', readonly=True, store=True) # Python code code = fields.Text(string='Python Code', groups='base.group_system', default=DEFAULT_PYTHON_CODE, help=\"Write Python code that the action will execute. Some variables are \" \"available for use; help about python expression is given in the help tab.\") # 省略代码 ... 当然你也可以从官方文档看到它的字段定义，https://www.odoo.com/documentation/13.0/reference/actions.html#server-actions-ir-actions-server。 可以从 state 字段看到 action 可以做如下几个事情： code - Execute Python Code 执行一段 Python 代码 object_create - Create a new Record 创建一条数据 object_write - Update the Record 更新数据 multi - Execute several actions 执行一系列的动作 如果我们要实现前面提到的功能，我们就需要用到 code 类型的服务器动作，来执行我们定义的 like 和 unlike 函数，于是我们就可以定义出这个服务器动作。 Like ir.actions.server code records.action_like() Unlike ir.actions.server code records.action_unlike() 那这个动作的入口在哪里呢？我们可以通过 binding_model_id 字段将它绑定到 tree 视图的 「动作」下来框。你肯定好奇，为什么这个字段没有在 ir.actions.server 模型中出现。因为 binding_model_id 字段存在于 ir.actions.actions 模型中，ir.actions.server 通过 _inherit = 'ir.actions.actions' 字段指定其将会继承 ir.actions.actions 模型，使其拥有 ir.actions.actions 的所有字段。 Odoo 的继承树就不在这里介绍了，感兴趣的可以阅读一下官方文档，https://www.odoo.com/documentation/13.0/reference/orm.html#inheritance-and-extension。 将这两个服务器动作定义完成后，更新模块你就可以在 bangumi 的 tree 视图中看到这个「动作」下拉框会新增 「Like」和 「Unlike」按钮。 &#x1F4A1;如果没看见 「动作」 下拉框，记得要选中几条记录。如果下拉框未出现「Like」和 「Unlike」按钮，可以尝试强制刷新浏览器或清除缓存。 "},"Chapter-7/Action-Url.html":{"url":"Chapter-7/Action-Url.html","title":"URL 动作","keywords":"","body":"链接动作定义用法视图中使用模型中使用链接动作 接下来介绍链接动作。顾名思义，就是通过一个动作，跳转到一个链接。 定义 主要是通过两个字段来自定义：url -- 激活action时所打开的链接。target -- 可选值new、self，默认new。new：在新窗口打开；self：替换当前页面内容。 用法 视图中使用 在xml视图中，定义一个act_url类型的的action。再此基础上，继续定义一个menu，将action内容指向定义的act_url。如下所示：定义了一个菜单百度搜索。点击此菜单时，会跳转到百度页面。 注意：还可以将url使用相对路径指向到其他模块的某页面或者controllers。 百度搜索 http://www.baidu.com self 效果如下： 模型中使用 可以作为按钮的点击函数，在函数中return一个链接action，打开链接。 { \"type\": \"ir.actions.act_url\", \"url\": \"https://odoo.com\", \"target\": \"self\", } "},"Chapter-7/Action-Client.html":{"url":"Chapter-7/Action-Client.html","title":"客户端动作","keywords":"","body":"客户端动作客户端动作 "},"Chapter-8/Odoo-Cron.html":{"url":"Chapter-8/Odoo-Cron.html","title":"计划任务 Cron","keywords":"","body":"计划任务 Cron计划任务 Cron "},"Chapter-9/Odoo-Access-Control.html":{"url":"Chapter-9/Odoo-Access-Control.html","title":"权限控制 Access Control","keywords":"","body":"权限控制 Access Control权限控制 Access Control "},"Chapter-9/Permission-Group.html":{"url":"Chapter-9/Permission-Group.html","title":"权限组","keywords":"","body":"权限组权限组 "},"Chapter-9/Menu-Permission.html":{"url":"Chapter-9/Menu-Permission.html","title":"菜单权限","keywords":"","body":"菜单权限菜单权限 "},"Chapter-9/Model-Permission.html":{"url":"Chapter-9/Model-Permission.html","title":"模型权限","keywords":"","body":"模型权限模型权限 "},"Chapter-9/DataSet-Permission.html":{"url":"Chapter-9/DataSet-Permission.html","title":"数据集权限","keywords":"","body":"数据集权限数据集权限 "},"Chapter-10/Odoo-Web-Controller.html":{"url":"Chapter-10/Odoo-Web-Controller.html","title":"Web 控制器 Web Controller","keywords":"","body":"Web 控制器 Web ControllerWeb 控制器 Web Controller "},"Chapter-10/Route-Control.html":{"url":"Chapter-10/Route-Control.html","title":"路由控制","keywords":"","body":"路由控制路由控制 "},"Chapter-10/Request.html":{"url":"Chapter-10/Request.html","title":"请求参数","keywords":"","body":"请求参数请求参数 "},"Chapter-10/Reponse.html":{"url":"Chapter-10/Reponse.html","title":"响应内容","keywords":"","body":"响应内容响应内容 "},"Chapter-10/Jinja2.html":{"url":"Chapter-10/Jinja2.html","title":"结合 Jinja2","keywords":"","body":"结合 Jinja2结合 Jinja2 "},"Chapter-11/Odoo-QWeb.html":{"url":"Chapter-11/Odoo-QWeb.html","title":"模版引擎 QWeb","keywords":"","body":"模版引擎 QWeb模版引擎 QWeb "},"Chapter-12/Odoo-i18n.html":{"url":"Chapter-12/Odoo-i18n.html","title":"国际化 i18n","keywords":"","body":"国际化 i18n国际化 i18n "}}